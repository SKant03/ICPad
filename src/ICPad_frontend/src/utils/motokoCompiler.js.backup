// Motoko Compiler Service using WebAssembly
class MotokoCompiler {
  constructor() {
    this.compilerLoaded = false;
    this.compiler = null;
  }

  async loadCompiler() {
    if (this.compilerLoaded) return;
    
    try {
      // Try to load Motoko compiler WASM module
      // For now, we'll use a simulation that provides better error reporting
      this.compilerLoaded = true;
      console.log('Motoko compiler service initialized');
    } catch (error) {
      console.error('Failed to load Motoko compiler:', error);
      throw error;
    }
  }

  async compile(code, options = {}) {
    await this.loadCompiler();
    
    // Enhanced simulation with better error detection
    const errors = this.validateMotokoCode(code);
    const warnings = this.detectWarnings(code);
    
    if (errors.length > 0) {
      return {
        success: false,
        output: `Compilation failed with ${errors.length} error(s)`,
        errors: errors,
        warnings: warnings,
        wasm: null,
        candid: null
      };
    }

    // Simulate successful compilation
    const wasmBytes = this.generateMockWasm();
    const candid = this.generateCandidInterface(code);
    
    return {
      success: true,
      output: 'Motoko compilation successful!',
      errors: [],
      warnings: warnings,
      wasm: wasmBytes,
      candid: candid
    };
  }

  validateMotokoCode(code) {
    const errors = [];
    const lines = code.split('\n');
    
    // Check for basic Motoko syntax
    if (!code.includes('actor') && !code.includes('module')) {
      errors.push('Missing actor or module declaration');
    }
    
    // Check for proper actor syntax
    if (code.includes('actor') && !code.match(/actor\s+\w+\s*{/)) {
      errors.push('Invalid actor declaration syntax');
    }
    
    // Check for function declarations
    if (code.includes('func') && !code.match(/func\s+\w+\s*\(/)) {
      errors.push('Invalid function declaration syntax');
    }
    
    // Check for missing semicolons
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.endsWith(';') && !trimmed.endsWith('{') && !trimmed.endsWith('}') && 
          !trimmed.startsWith('//') && !trimmed.startsWith('/*') && !trimmed.includes('import')) {
        if (trimmed.includes('=') || trimmed.includes('return') || trimmed.includes('let')) {
          errors.push(`Line ${index + 1}: Missing semicolon`);
        }
      }
    });
    
    // Check for unmatched braces
    let braceCount = 0;
    lines.forEach((line, index) => {
      const openBraces = (line.match(/{/g) || []).length;
      const closeBraces = (line.match(/}/g) || []).length;
      braceCount += openBraces - closeBraces;
      
      if (braceCount < 0) {
        errors.push(`Line ${index + 1}: Unexpected closing brace`);
      }
    });
    
    if (braceCount > 0) {
      errors.push('Unmatched opening braces');
    }
    
    return errors;
  }

  detectWarnings(code) {
    const warnings = [];
    const lines = code.split('\n');
    
    // Check for unused variables
    const variableDeclarations = [];
    const variableUsage = [];
    
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      
      // Find variable declarations
      const letMatch = trimmed.match(/let\s+(\w+)/);
      if (letMatch) {
        variableDeclarations.push({ name: letMatch[1], line: index + 1 });
      }
      
      // Find variable usage
      const varMatch = trimmed.match(/\b(\w+)\b/g);
      if (varMatch) {
        varMatch.forEach(varName => {
          if (!['actor', 'func', 'let', 'var', 'if', 'else', 'for', 'while', 'return', 'import'].includes(varName)) {
            variableUsage.push(varName);
          }
        });
      }
    });
    
    // Check for unused variables
    variableDeclarations.forEach(decl => {
      if (!variableUsage.includes(decl.name)) {
        warnings.push(`Line ${decl.line}: Unused variable '${decl.name}'`);
      }
    });
    
    return warnings;
  }

  generateMockWasm() {
    // Generate a mock WASM binary (simplified)
    const wasmHeader = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, // WASM magic number
      0x01, 0x00, 0x00, 0x00  // Version 1
    ]);
    
    // Add some mock WASM content
    const mockContent = new Uint8Array(1024); // 1KB mock WASM
    for (let i = 0; i < mockContent.length; i++) {
      mockContent[i] = Math.floor(Math.random() * 256);
    }
    
    return new Uint8Array([...wasmHeader, ...mockContent]);
  }

  generateCandidInterface(code) {
    // Extract function signatures and generate Candid interface
    const functions = [];
    const lines = code.split('\n');
    
    lines.forEach(line => {
      const funcMatch = line.match(/public\s+func\s+(\w+)\s*\(([^)]*)\)\s*:\s*async\s*([^;]+)/);
      if (funcMatch) {
        const [, funcName, params, returnType] = funcMatch;
        const paramList = params.split(',').map(p => p.trim()).filter(p => p);
        const candidParams = paramList.map(p => {
          const [name, type] = p.split(':').map(s => s.trim());
          return `${name}: ${type}`;
        }).join(', ');
        
        functions.push(`  ${funcName}: (${candidParams}) -> (${returnType.trim()})`);
      }
    });
    
    if (functions.length === 0) {
      return '// No public functions found';
    }
    
    return `service : {
${functions.join('\n')}
}`;
  }
}

export default MotokoCompiler;
