import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { 
  createProject, 
  getProject, 
  listProjects, 
  updateProjectCode, 
  compileProject, 
  deployProjectWithWasm,
  callFunction,
  testProject,
  checkCanisterConnection
} from '../utils/canisterService';
import { PrincipalContext } from './PrincipalContext';

const IDEContext = createContext();

export const useIDE = () => {
  const context = useContext(IDEContext);
  if (!context) {
    throw new Error('useIDE must be used within an IDEProvider');
  }
  return context;
};

export const IDEProvider = ({ children }) => {
  const { principal, isAuthenticated, isLoading: authLoading } = useContext(PrincipalContext);
  const [projects, setProjects] = useState([]);
  const [currentProject, setCurrentProject] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [terminalOutput, setTerminalOutput] = useState([]);
  const [compilationResult, setCompilationResult] = useState(null);
  const [showCompilationResults, setShowCompilationResults] = useState(false);
  const [code, setCode] = useState("");
  const [originalCode, setOriginalCode] = useState(""); // Track original code
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // Update connection status based on authentication and canister connection
  useEffect(() => {
    const checkConnectionStatus = async () => {
      // Don't check if still loading authentication
      if (authLoading) {
        return;
      }

      try {
        const result = await checkCanisterConnection();
        const canisterConnected = result.success && result.connected;
        
        // Only connected if both authenticated AND canister is reachable
        const connected = isAuthenticated && canisterConnected;
        setIsConnected(connected);
        
        if (connected) {
          addTerminalOutput('âœ… Connected to Internet Computer');
        } else if (!isAuthenticated) {
          addTerminalOutput('âŒ Please log in with Internet Identity');
        } else if (!canisterConnected) {
          addTerminalOutput('âŒ Disconnected from Internet Computer');
        }
      } catch (error) {
        setIsConnected(false);
        addTerminalOutput('âŒ Connection error: ' + error.message);
      }
    };

    checkConnectionStatus();
  }, [isAuthenticated, authLoading]);

  // Load projects on mount
  useEffect(() => {
    loadProjects();
  }, []);

  // Check if code has changed from the deployed version
  useEffect(() => {
    if (currentProject && code !== originalCode) {
      // Code has changed, mark as not deployed
      setCurrentProject(prev => prev ? { ...prev, deployed: false, canister_id: null } : null);
      setHasUnsavedChanges(true);
      addTerminalOutput('âš ï¸ Code changed - project needs to be redeployed');
    } else if (currentProject && code === originalCode) {
      setHasUnsavedChanges(false);
    }
  }, [code, originalCode, currentProject]);

  // Auto-save functionality (debounced)
  useEffect(() => {
    if (!currentProject || !hasUnsavedChanges) return;

    const timeoutId = setTimeout(() => {
      autoSave();
    }, 2000); // Auto-save after 2 seconds of inactivity

    return () => clearTimeout(timeoutId);
  }, [code, currentProject, hasUnsavedChanges]);

  const addTerminalOutput = (message) => {
    setTerminalOutput(prev => [...prev, { message, timestamp: new Date().toISOString() }]);
  };

  const autoSave = useCallback(async () => {
    if (!currentProject || !hasUnsavedChanges) return;

    try {
      console.log('Auto-saving project...', currentProject.id);
      const result = await updateProjectCode(currentProject.id, code);
      if (result.success) {
        addTerminalOutput('ðŸ’¾ Auto-saved project');
        setCurrentProject(prev => prev ? { ...prev, code, updated_at: Date.now() } : null);
        setOriginalCode(code); // Update original code after saving
        setHasUnsavedChanges(false);
      } else {
        addTerminalOutput('âŒ Auto-save failed: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Auto-save error: ' + error.message);
    }
  }, [currentProject, code, hasUnsavedChanges]);

  const checkConnection = async () => {
    try {
      const result = await checkCanisterConnection();
      if (result.success) {
        const canisterConnected = result.connected;
        const connected = isAuthenticated && canisterConnected;
        setIsConnected(connected);
        
        if (connected) {
          addTerminalOutput('âœ… Connected to Internet Computer');
        } else if (!isAuthenticated) {
          addTerminalOutput('âŒ Please log in with Internet Identity');
        } else {
          addTerminalOutput('âŒ Disconnected from Internet Computer');
        }
      } else {
        setIsConnected(false);
        addTerminalOutput('âŒ Connection check failed: ' + result.error);
      }
    } catch (error) {
      setIsConnected(false);
      addTerminalOutput('âŒ Connection error: ' + error.message);
    }
  };

  const loadProjects = async () => {
    try {
      console.log('Loading projects...');
      const result = await listProjects();
      console.log('Projects result:', result);
      
      if (result.success) {
        setProjects(result.projects);
      } else {
        console.error('Failed to load projects:', result.error);
        addTerminalOutput('âŒ Failed to load projects: ' + result.error);
      }
    } catch (error) {
      console.error('Error loading projects:', error);
      addTerminalOutput('âŒ Error loading projects: ' + error.message);
    }
  };

  const createNewProject = async (name, language, initialCode) => {
    try {
      const result = await createProject(name, language, initialCode);
      if (result.success) {
        addTerminalOutput(`âœ… Created project: ${name} (${language})`);
        await loadProjects(); // Refresh projects list
        return result.projectId;
      } else {
        addTerminalOutput('âŒ Failed to create project: ' + result.error);
        return null;
      }
    } catch (error) {
      addTerminalOutput('âŒ Error creating project: ' + error.message);
      return null;
    }
  };

  const loadProject = async (projectId) => {
    try {
      console.log('Loading project with ID:', projectId);
      const result = await getProject(projectId);
      console.log('Project load result:', result);
      
      if (result.success) {
        setCurrentProject(result.project);
        setCode(result.project.code); // Set the code in the editor
        setOriginalCode(result.project.code); // Set original code for comparison
        setHasUnsavedChanges(false);
        console.log('Setting current project:', result.project);
        addTerminalOutput(`âœ… Loaded project: ${result.project.name}`);
        return true;
      } else {
        addTerminalOutput('âŒ Failed to load project: ' + result.error);
        return false;
      }
    } catch (error) {
      addTerminalOutput('âŒ Error loading project: ' + error.message);
      return false;
    }
  };

  const saveCurrentProject = async () => {
    if (!currentProject) {
      addTerminalOutput('âŒ No project selected for saving');
      return;
    }

    try {
      console.log('Manually saving project...', currentProject.id, 'Code length:', code.length);
      const result = await updateProjectCode(currentProject.id, code);
      if (result.success) {
        addTerminalOutput('ðŸ’¾ Project saved manually');
        // Update the current project with the new code
        setCurrentProject(prev => prev ? { ...prev, code, updated_at: Date.now() } : null);
        setOriginalCode(code); // Update original code after saving
        setHasUnsavedChanges(false);
      } else {
        addTerminalOutput('âŒ Failed to save project: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Error saving project: ' + error.message);
    }
  };

  // FIXED: Compilation now uses current editor code
  const compileCurrentProject = async () => {
    if (!currentProject) {
      addTerminalOutput('âŒ No project selected for compilation');
      return;
    }

    // Auto-save before compiling
    if (hasUnsavedChanges) {
      await autoSave();
    }

    setIsLoading(true);
    addTerminalOutput('ðŸ”¨ Compiling project...');
    addTerminalOutput(`ðŸ“ Using current editor code (${code.length} characters)`);
    
    try {
      // FIXED: Pass current code to compilation
      const result = await compileProject(currentProject.id, code);
      if (result.success) {
        const compileResult = result.result;
        setCompilationResult(compileResult);
        setShowCompilationResults(true);
        
        if (compileResult.success) {
          addTerminalOutput('âœ… Compilation successful!');
          addTerminalOutput(compileResult.output);
          
          if (compileResult.wasm) {
            addTerminalOutput(`ðŸ“¦ Generated WASM: ${compileResult.wasm.length} bytes`);
          }
          if (compileResult.candid) {
            addTerminalOutput(`ðŸ“„ Generated Candid interface`);
          }
        } else {
          addTerminalOutput('âŒ Compilation failed!');
          addTerminalOutput(compileResult.output);
          if (compileResult.errors && compileResult.errors.length > 0) {
            compileResult.errors.forEach(error => {
              addTerminalOutput(`  - ${error}`);
            });
          }
        }
      } else {
        addTerminalOutput('âŒ Failed to compile: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Error during compilation: ' + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // FIXED: Deployment now uses current editor code
  const deployCurrentProject = async () => {
    if (!currentProject) {
      addTerminalOutput('âŒ No project selected for deployment');
      return;
    }

    // Auto-save before deploying
    if (hasUnsavedChanges) {
      await autoSave();
    }

    setIsLoading(true);
    addTerminalOutput('ðŸš€ Deploying project to Internet Computer...');
    addTerminalOutput(`ðŸ“ Using current editor code (${code.length} characters)`);
    
    try {
      // FIXED: First compile with current code to get WASM
      const compileResult = await compileProject(currentProject.id, code);
      if (!compileResult.success) {
        addTerminalOutput('âŒ Compilation failed, cannot deploy');
        return;
      }

      const { wasm, candid } = compileResult.result;
      if (!wasm || !candid) {
        addTerminalOutput('âŒ No WASM or Candid generated, cannot deploy');
        return;
      }

      // Deploy with WASM
      const result = await deployProjectWithWasm(currentProject.id, wasm, candid);
      if (result.success) {
        const deployResult = result.result;
        addTerminalOutput('âœ… Deployment successful!');
        addTerminalOutput(`ðŸŒ Canister ID: ${deployResult.canister_id}`);
        addTerminalOutput(`ðŸ”— URL: ${deployResult.url}`);
        addTerminalOutput(`ðŸ“¦ WASM Size: ${deployResult.wasm_size} bytes`);
        addTerminalOutput(deployResult.output);
        
        // Update current project with deployment info
        await loadProject(currentProject.id);
        setOriginalCode(code); // Update original code after deployment
      } else {
        addTerminalOutput('âŒ Deployment failed: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Error during deployment: ' + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const callProjectFunction = async (functionName, args = []) => {
    if (!currentProject) {
      addTerminalOutput('âŒ No project selected for function call');
      return;
    }

    if (!currentProject.deployed) {
      addTerminalOutput('âŒ Project not deployed, cannot call functions');
      return;
    }

    addTerminalOutput(`ðŸ”§ Calling function: ${functionName}(${args.join(', ')})`);
    
    try {
      const result = await callFunction(currentProject.id, functionName, args);
      if (result.success) {
        const callResult = result.result;
        if (callResult.success) {
          addTerminalOutput(`âœ… Function result: ${callResult.result}`);
        } else {
          addTerminalOutput(`âŒ Function error: ${callResult.error}`);
        }
      } else {
        addTerminalOutput('âŒ Failed to call function: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Error calling function: ' + error.message);
    }
  };

  const testCurrentProject = async (testInput) => {
    if (!currentProject) {
      addTerminalOutput('âŒ No project selected for testing');
      return;
    }

    addTerminalOutput(`ðŸ§ª Testing project with input: "${testInput}"`);
    
    try {
      const result = await testProject(currentProject.id, testInput);
      if (result.success) {
        addTerminalOutput(`âœ… ${result.result}`);
      } else {
        addTerminalOutput('âŒ Test failed: ' + result.error);
      }
    } catch (error) {
      addTerminalOutput('âŒ Error during testing: ' + error.message);
    }
  };

  const clearTerminal = () => {
    setTerminalOutput([]);
  };

  // NEW: Close compilation results
  const closeCompilationResults = () => {
    setShowCompilationResults(false);
  };

  // NEW: Test getMessage function
  const testGetMessage = async () => {
    await callProjectFunction('getMessage', []);
  };

  // NEW: Test greet function
  const testGreet = async () => {
    await callProjectFunction('greet', ['World']);
  };

  // NEW: Test whoami function
  const testWhoami = async () => {
    await callProjectFunction('whoami', []);
  };

  const value = {
    projects,
    currentProject,
    isLoading,
    isConnected,
    terminalOutput,
    compilationResult,
    showCompilationResults,
    setShowCompilationResults,
    closeCompilationResults,
    code,
    setCode,
    hasUnsavedChanges,
    loadProjects,
    createNewProject,
    loadProject,
    saveCurrentProject,
    compileCurrentProject,
    deployCurrentProject,
    callProjectFunction,
    testCurrentProject,
    testGetMessage,
    testGreet,
    testWhoami,
    addTerminalOutput,
    clearTerminal,
    checkConnection,
  };

  return (
    <IDEContext.Provider value={value}>
      {children}
    </IDEContext.Provider>
  );
};
